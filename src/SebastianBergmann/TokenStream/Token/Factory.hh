<?hh // strict

namespace SebastianBergmann\TokenStream\Token;

use SebastianBergmann\TokenStream\Token\Stream;
use SebastianBergmann\TokenStream\TokenInterface;

// --
// The contents of this switch is autogenerated by the ./bin/generate-token-factory-code.hh
// --
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Abstract;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Ampersand;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_And_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Array;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Array_Cast;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_As;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Async;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_At;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Await;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Backtick;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Bad_Character;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Bool_Cast;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Boolean_And;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Boolean_Or;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Break;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Callable;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Caret;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Case;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Catch;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Character;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Class;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Class_C;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Class_Name_Constant;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Clone;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Close_Bracket;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Close_Curly;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Close_Square;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Close_Tag;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Coalesce;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Colon;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Comma;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Comment;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Compiler_Halt_Offset;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Concat_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Const;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Constant_Encapsed_String;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Continue;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Curly_Open;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Dec;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Declare;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Default;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Dir;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Div;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Div_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Dnumber;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Do;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Doc_Comment;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Dollar;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Dollar_Open_Curly_Braces;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Dot;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Double_Arrow;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Double_Cast;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Double_Colon;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Double_Quotes;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Echo;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Ellipsis;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Else;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Elseif;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Empty;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Encapsed_And_Whitespace;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Enddeclare;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Endfor;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Endforeach;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Endif;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Endswitch;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Endwhile;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_End_Heredoc;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Enum;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Equals;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Eval;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Exclamation_Mark;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Exit;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Extends;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_File;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Final;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Finally;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_For;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Foreach;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Func_C;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Function;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Global;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Goto;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Gt;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Halt_Compiler;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_If;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Implements;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_In;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Inc;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Include;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Include_Once;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Inline_Html;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Instanceof;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Insteadof;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Int_Cast;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Interface;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Invariant;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Is_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Is_Greater_Or_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Is_Identical;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Is_Not_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Is_Not_Identical;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Is_Smaller_Or_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Isset;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Join;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Lambda_Arrow;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Lambda_Cp;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Lambda_Op;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Line;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_List;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Lnumber;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Logical_Or;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Logical_Xor;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Logical_And;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Lt;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Method_C;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Minus;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Minus_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Mod_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Mul_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Mult;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Namespace;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_New;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Ns_C;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Ns_Separator;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Nullsafe_Object_Operator;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Num_String;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Object_Cast;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Object_Operator;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Onumber;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Open_Bracket;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Open_Curly;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Open_Square;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Open_Tag;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Open_Tag_With_Echo;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Or_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Paamayim_Nekudotayim;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Percent;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Pipe;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Plus;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Plus_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Pow;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Pow_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Print;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Private;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Protected;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Public;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Question_Mark;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Require;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Require_Once;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Return;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Semicolon;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Shape;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Sl;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Sl_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Spaceship;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Sr;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Sr_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Start_Heredoc;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Static;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_String;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_String_Cast;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_String_Varname;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Super;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Switch;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Throw;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Tilde;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Trait;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Trait_C;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Try;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Tuple;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Type;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Typelist_Gt;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Typelist_Lt;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Unset;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Unset_Cast;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Use;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Use_Function;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Var;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Variable;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Where;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_While;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Whitespace;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xhp_Attribute;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xhp_Category;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xhp_Category_Label;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xhp_Children;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xhp_Label;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xhp_Required;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xhp_Tag_Gt;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xhp_Tag_Lt;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xhp_Text;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Xor_Equal;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Yield;
use SebastianBergmann\TokenStream\Tokens\PHP_Token_Yield_From;

use Zynga\CodeBase\V1\File;
use \ReflectionClass;
use \Exception;

class Factory {

  private static Map<string, TokenInterface>
    $_tokenTemplateCacheByName = Map {};
  private static Map<int, TokenInterface> $_tokenTemplateCacheById = Map {};

  public static function createTokenFromTokenId(
    int $tokenId,
  ): ?TokenInterface {

    // --
    // JEO: Temporarily commenting out the clone behavior, found a instance
    // where the cloning wasn't pure and ended up adding more data to a childs
    // member variables.
    // --

    // $templateToken = self::$_tokenTemplateCacheById->get($tokenId);
    //
    // if ($templateToken instanceof TokenInterface) {
    //   $token = clone $templateToken;
    //   return $token;
    // }

    $templateToken = self::createTokenFromTokenIdRaw($tokenId);

    if ($templateToken instanceof TokenInterface) {
      //self::$_tokenTemplateCacheById->set($tokenId, $templateToken);
      // We clone to make sure that we don't hand back a ref to our template.
      //$token = clone $templateToken;
      return $templateToken;
    }

    return null;
  }

  private static function createTokenFromTokenIdRaw(
    int $tokenId,
  ): ?TokenInterface {
    if ($tokenId == T_REQUIRE_ONCE) {
      return new PHP_Token_Require_Once();
    }
    if ($tokenId == T_REQUIRE) {
      return new PHP_Token_Require();
    }
    if ($tokenId == T_EVAL) {
      return new PHP_Token_Eval();
    }
    if ($tokenId == T_INCLUDE_ONCE) {
      return new PHP_Token_Include_Once();
    }
    if ($tokenId == T_INCLUDE) {
      return new PHP_Token_Include();
    }
    if ($tokenId == T_LOGICAL_OR) {
      return new PHP_Token_Logical_Or();
    }
    if ($tokenId == T_LOGICAL_XOR) {
      return new PHP_Token_Logical_Xor();
    }
    if ($tokenId == T_LOGICAL_AND) {
      return new PHP_Token_Logical_And();
    }
    if ($tokenId == T_PRINT) {
      return new PHP_Token_Print();
    }
    if ($tokenId == T_SR_EQUAL) {
      return new PHP_Token_Sr_Equal();
    }
    if ($tokenId == T_SL_EQUAL) {
      return new PHP_Token_Sl_Equal();
    }
    if ($tokenId == T_XOR_EQUAL) {
      return new PHP_Token_Xor_Equal();
    }
    if ($tokenId == T_AND_EQUAL) {
      return new PHP_Token_And_Equal();
    }
    if ($tokenId == T_MOD_EQUAL) {
      return new PHP_Token_Mod_Equal();
    }
    if ($tokenId == T_CONCAT_EQUAL) {
      return new PHP_Token_Concat_Equal();
    }
    if ($tokenId == T_DIV_EQUAL) {
      return new PHP_Token_Div_Equal();
    }
    if ($tokenId == T_MUL_EQUAL) {
      return new PHP_Token_Mul_Equal();
    }
    if ($tokenId == T_MINUS_EQUAL) {
      return new PHP_Token_Minus_Equal();
    }
    if ($tokenId == T_PLUS_EQUAL) {
      return new PHP_Token_Plus_Equal();
    }
    if ($tokenId == T_BOOLEAN_OR) {
      return new PHP_Token_Boolean_Or();
    }
    if ($tokenId == T_BOOLEAN_AND) {
      return new PHP_Token_Boolean_And();
    }
    if ($tokenId == T_IS_NOT_IDENTICAL) {
      return new PHP_Token_Is_Not_Identical();
    }
    if ($tokenId == T_IS_NOT_EQUAL) {
      return new PHP_Token_Is_Identical();
    }
    if ($tokenId == T_IS_NOT_EQUAL) {
      return new PHP_Token_Is_Not_Equal();
    }
    if ($tokenId == T_IS_EQUAL) {
      return new PHP_Token_Is_Equal();
    }
    if ($tokenId == T_IS_GREATER_OR_EQUAL) {
      return new PHP_Token_Is_Greater_Or_Equal();
    }
    if ($tokenId == T_IS_SMALLER_OR_EQUAL) {
      return new PHP_Token_Is_Smaller_Or_Equal();
    }
    if ($tokenId == T_SR) {
      return new PHP_Token_Sr();
    }
    if ($tokenId == T_SL) {
      return new PHP_Token_Sl();
    }
    if ($tokenId == T_INSTANCEOF) {
      return new PHP_Token_Insteadof();
    }
    if ($tokenId == T_UNSET) {
      return new PHP_Token_Unset();
    }
    if ($tokenId == T_UNSET_CAST) {
      return new PHP_Token_Unset_Cast();
    }
    if ($tokenId == T_BOOL_CAST) {
      return new PHP_Token_Bool_Cast();
    }
    if ($tokenId == T_OBJECT_CAST) {
      return new PHP_Token_Object_Cast();
    }
    if ($tokenId == T_ARRAY_CAST) {
      return new PHP_Token_Array_Cast();
    }
    if ($tokenId == T_STRING_CAST) {
      return new PHP_Token_String_Cast();
    }
    if ($tokenId == T_DOUBLE_CAST) {
      return new PHP_Token_Double_Cast();
    }
    if ($tokenId == T_INT_CAST) {
      return new PHP_Token_Int_Cast();
    }
    if ($tokenId == T_DEC) {
      return new PHP_Token_Dec();
    }
    if ($tokenId == T_INC) {
      return new PHP_Token_Inc();
    }
    if ($tokenId == T_CLONE) {
      return new PHP_Token_Clone();
    }
    if ($tokenId == T_NEW) {
      return new PHP_Token_New();
    }
    if ($tokenId == T_EXIT) {
      return new PHP_Token_Exit();
    }
    if ($tokenId == T_IF) {
      return new PHP_Token_If();
    }
    if ($tokenId == T_ELSEIF) {
      return new PHP_Token_Elseif();
    }
    if ($tokenId == T_ELSE) {
      return new PHP_Token_Else();
    }
    if ($tokenId == T_LNUMBER) {
      return new PHP_Token_Lnumber();
    }
    if ($tokenId == T_DNUMBER) {
      return new PHP_Token_Dnumber();
    }
    if ($tokenId == T_STRING) {
      return new PHP_Token_String();
    }
    if ($tokenId == T_STRING_VARNAME) {
      return new PHP_Token_String_Varname();
    }
    if ($tokenId == T_VARIABLE) {
      return new PHP_Token_Variable();
    }
    if ($tokenId == T_NUM_STRING) {
      return new PHP_Token_Num_String();
    }
    if ($tokenId == T_INLINE_HTML) {
      return new PHP_Token_Inline_Html();
    }
    if ($tokenId == T_CHARACTER) {
      return new PHP_Token_Character();
    }
    if ($tokenId == T_BAD_CHARACTER) {
      return new PHP_Token_Bad_Character();
    }
    if ($tokenId == T_ENCAPSED_AND_WHITESPACE) {
      return new PHP_Token_Encapsed_And_Whitespace();
    }
    if ($tokenId == T_CONSTANT_ENCAPSED_STRING) {
      return new PHP_Token_Constant_Encapsed_String();
    }
    if ($tokenId == T_ECHO) {
      return new PHP_Token_Echo();
    }
    if ($tokenId == T_DO) {
      return new PHP_Token_Do();
    }
    if ($tokenId == T_WHILE) {
      return new PHP_Token_While();
    }
    if ($tokenId == T_ENDWHILE) {
      return new PHP_Token_Endwhile();
    }
    if ($tokenId == T_FOR) {
      return new PHP_Token_For();
    }
    if ($tokenId == T_ENDFOR) {
      return new PHP_Token_Endfor();
    }
    if ($tokenId == T_FOREACH) {
      return new PHP_Token_Foreach();
    }
    if ($tokenId == T_ENDFOREACH) {
      return new PHP_Token_Endforeach();
    }
    if ($tokenId == T_DECLARE) {
      return new PHP_Token_Declare();
    }
    if ($tokenId == T_ENDDECLARE) {
      return new PHP_Token_Enddeclare();
    }
    if ($tokenId == T_AS) {
      return new PHP_Token_As();
    }
    if ($tokenId == T_SWITCH) {
      return new PHP_Token_Switch();
    }
    if ($tokenId == T_ENDSWITCH) {
      return new PHP_Token_Endswitch();
    }
    if ($tokenId == T_CASE) {
      return new PHP_Token_Case();
    }
    if ($tokenId == T_DEFAULT) {
      return new PHP_Token_Default();
    }
    if ($tokenId == T_BREAK) {
      return new PHP_Token_Break();
    }
    if ($tokenId == T_GOTO) {
      return new PHP_Token_Goto();
    }
    if ($tokenId == T_CONTINUE) {
      return new PHP_Token_Continue();
    }
    if ($tokenId == T_FUNCTION) {
      return new PHP_Token_Function();
    }
    if ($tokenId == T_CONST) {
      return new PHP_Token_Const();
    }
    if ($tokenId == T_RETURN) {
      return new PHP_Token_Return();
    }
    if ($tokenId == T_TRY) {
      return new PHP_Token_Try();
    }
    if ($tokenId == T_CATCH) {
      return new PHP_Token_Catch();
    }
    if ($tokenId == T_THROW) {
      return new PHP_Token_Throw();
    }
    if ($tokenId == T_USE) {
      return new PHP_Token_Use();
    }
    if ($tokenId == T_GLOBAL) {
      return new PHP_Token_Global();
    }
    if ($tokenId == T_PUBLIC) {
      return new PHP_Token_Public();
    }
    if ($tokenId == T_PROTECTED) {
      return new PHP_Token_Protected();
    }
    if ($tokenId == T_PRIVATE) {
      return new PHP_Token_Private();
    }
    if ($tokenId == T_FINAL) {
      return new PHP_Token_Final();
    }
    if ($tokenId == T_ABSTRACT) {
      return new PHP_Token_Abstract();
    }
    if ($tokenId == T_STATIC) {
      return new PHP_Token_Static();
    }
    if ($tokenId == T_VAR) {
      return new PHP_Token_Var();
    }
    if ($tokenId == T_UNSET) {
      return new PHP_Token_Unset();
    }
    if ($tokenId == T_ISSET) {
      return new PHP_Token_Isset();
    }
    if ($tokenId == T_EMPTY) {
      return new PHP_Token_Empty();
    }
    if ($tokenId == T_HALT_COMPILER) {
      return new PHP_Token_Halt_Compiler();
    }
    if ($tokenId == T_CLASS) {
      return new PHP_Token_Class();
    }
    if ($tokenId == T_INTERFACE) {
      return new PHP_Token_Interface();
    }
    if ($tokenId == T_EXTENDS) {
      return new PHP_Token_Extends();
    }
    if ($tokenId == T_IMPLEMENTS) {
      return new PHP_Token_Implements();
    }
    if ($tokenId == T_OBJECT_OPERATOR) {
      return new PHP_Token_Object_Operator();
    }
    if ($tokenId == T_DOUBLE_ARROW) {
      return new PHP_Token_Double_Arrow();
    }
    if ($tokenId == T_LIST) {
      return new PHP_Token_List();
    }
    if ($tokenId == T_ARRAY) {
      return new PHP_Token_Array();
    }
    if ($tokenId == T_CLASS_C) {
      return new PHP_Token_Class_C();
    }
    if ($tokenId == T_METHOD_C) {
      return new PHP_Token_Method_C();
    }
    if ($tokenId == T_FUNC_C) {
      return new PHP_Token_Func_C();
    }
    if ($tokenId == T_LINE) {
      return new PHP_Token_Line();
    }
    if ($tokenId == T_FILE) {
      return new PHP_Token_File();
    }
    if ($tokenId == T_COMMENT) {
      return new PHP_Token_Comment();
    }
    if ($tokenId == T_DOC_COMMENT) {
      return new PHP_Token_Doc_Comment();
    }
    if ($tokenId == T_OPEN_TAG) {
      return new PHP_Token_Open_Tag();
    }
    if ($tokenId == T_OPEN_TAG_WITH_ECHO) {
      return new PHP_Token_Open_Tag_With_Echo();
    }
    if ($tokenId == T_CLOSE_TAG) {
      return new PHP_Token_Close_Tag();
    }
    if ($tokenId == T_WHITESPACE) {
      return new PHP_Token_Whitespace();
    }
    if ($tokenId == T_START_HEREDOC) {
      return new PHP_Token_Start_Heredoc();
    }
    if ($tokenId == T_END_HEREDOC) {
      return new PHP_Token_End_Heredoc();
    }
    if ($tokenId == T_DOLLAR_OPEN_CURLY_BRACES) {
      return new PHP_Token_Dollar_Open_Curly_Braces();
    }
    if ($tokenId == T_CURLY_OPEN) {
      return new PHP_Token_Curly_Open();
    }
    // --
    // JEO: Currently unused, but stubbing it in jic it is used in the future.
    //const int UserTokenId_T_PAAMAYIM_NEKUDOTAYIM UNUSED = 376;
    //if ($tokenId == T_PAAMAYIM_NEKUDOTAYIM) {
    //  return new PHP_Token_XXX();
    //}
    // --
    if ($tokenId == T_NAMESPACE) {
      return new PHP_Token_Namespace();
    }
    if ($tokenId == T_NS_C) {
      return new PHP_Token_Ns_C();
    }
    if ($tokenId == T_DIR) {
      return new PHP_Token_Dir();
    }
    if ($tokenId == T_NS_SEPARATOR) {
      return new PHP_Token_Ns_Separator();
    }
    if ($tokenId == T_YIELD) {
      return new PHP_Token_Yield();
    }
    if ($tokenId == T_XHP_LABEL) {
      return new PHP_Token_Xhp_Label();
    }
    if ($tokenId == T_XHP_ATTRIBUTE) {
      return new PHP_Token_Xhp_Attribute();
    }
    if ($tokenId == T_XHP_CATEGORY) {
      return new PHP_Token_Xhp_Category();
    }
    if ($tokenId == T_XHP_CATEGORY_LABEL) {
      return new PHP_Token_Xhp_Category_Label();
    }
    if ($tokenId == T_XHP_CHILDREN) {
      return new PHP_Token_Xhp_Children();
    }
    if ($tokenId == T_ENUM) {
      return new PHP_Token_Enum();
    }
    if ($tokenId == T_XHP_REQUIRED) {
      return new PHP_Token_Xhp_Required();
    }
    if ($tokenId == T_TRAIT) {
      return new PHP_Token_Trait();
    }
    if ($tokenId == T_INSTEADOF) {
      return new PHP_Token_Insteadof();
    }
    if ($tokenId == T_TRAIT_C) {
      return new PHP_Token_Trait_C();
    }
    if ($tokenId == T_ELLIPSIS) {
      return new PHP_Token_Ellipsis();
    }
    // --
    // Defined int he types list, but don't know if it's actually used.
    //if ($tokenId == T_HH_ERROR) {
    //  return new PHP_Token_Hh_Error();
    //}
    // --
    if ($tokenId == T_FINALLY) {
      return new PHP_Token_Finally();
    }
    if ($tokenId == T_XHP_TAG_LT) {
      return new PHP_Token_Xhp_Tag_Lt();
    }
    if ($tokenId == T_XHP_TAG_GT) {
      return new PHP_Token_Xhp_Tag_Gt();
    }
    if ($tokenId == T_TYPELIST_LT) {
      return new PHP_Token_Typelist_Lt();
    }
    if ($tokenId == T_TYPELIST_GT) {
      return new PHP_Token_Typelist_Gt();
    }
    // JEO: We don't currently have a token for this one yet, do we need one?
    //if ($tokenId == T_UNRESOLVED_LT) {
    //  return new PHP_Token_Unresolved_Lt();
    //}
    // const int UserTokenId_T_COLLECTION = 401;
    //if ($tokenId == T_COLLECTION) {
    //  return new PHP_Token_Collection();
    //}
    if ($tokenId == T_SHAPE) {
      return new PHP_Token_Shape();
    }
    if ($tokenId == T_TYPE) {
      return new PHP_Token_Type();
    }
    // const int UserTokenId_T_UNRESOLVED_TYPE = 404;
    //if ($tokenId == T_UNRESOLVED_TYPE) {
    //  return new PHP_Token_Unresolved_Type();
    //}
    // const int UserTokenId_T_NEWTYPE = 405;
    // if ($tokenId == T_NEWTYPE) {
    //   return new PHP_Token_Newtype();
    // }
    // const int UserTokenId_T_NEWTYPE = 405;
    //if ($tokenId == T_UNRESOLVED_NEWTYPE) {
    //  return new PHP_Token_Unresolved_Newtype();
    //}
    if ($tokenId == T_COMPILER_HALT_OFFSET) {
      return new PHP_Token_Compiler_Halt_Offset();
    }
    if ($tokenId == T_AWAIT) {
      return new PHP_Token_Await();
    }
    if ($tokenId == T_ASYNC) {
      return new PHP_Token_Async();
    }
    if ($tokenId == T_LAMBDA_ARROW) {
      return new PHP_Token_Lambda_Arrow();
    }
    if ($tokenId == T_DOUBLE_COLON) {
      return new PHP_Token_Double_Colon();
    }
    if ($tokenId == T_LAMBDA_OP) {
      return new PHP_Token_Lambda_Op();
    }
    if ($tokenId == T_LAMBDA_CP) {
      return new PHP_Token_Lambda_Cp();
    }
    // const int UserTokenId_T_UNRESOLVED_OP = 429;
    //if ($tokenId == T_UNRESOLVED_OP) {
    //  return new PHP_Token_Unresolved_Op();
    //}
    if ($tokenId == T_CALLABLE) {
      return new PHP_Token_Callable();
    }
    if ($tokenId == T_ONUMBER) {
      return new PHP_Token_Onumber();
    }
    if ($tokenId == T_POW) {
      return new PHP_Token_Pow();
    }
    if ($tokenId == T_POW_EQUAL) {
      return new PHP_Token_Pow_Equal();
    }
    if ($tokenId == T_NULLSAFE_OBJECT_OPERATOR) {
      return new PHP_Token_Nullsafe_Object_Operator();
    }
    //const int UserTokenId_T_HASHBANG = 435;
    //if ($tokenId == T_HASHBANG) {
    //  return new PHP_Token_Hashbang();
    //}
    if ($tokenId == T_SUPER) {
      return new PHP_Token_Super();
    }
    if ($tokenId == T_SPACESHIP) {
      return new PHP_Token_Spaceship();
    }
    // const int UserTokenId_T_COALESCE = 438;
    // if ($tokenId == T_COALESCE) {
    //   return new PHP_Token_Colaesce();
    // }
    if ($tokenId == T_YIELD_FROM) {
      return new PHP_Token_Yield_From();
    }
    if ($tokenId == T_PIPE) {
      return new PHP_Token_Pipe();
    }
    // const int UserTokenId_T_PIPE_VAR = 441;
    // if ($tokenId == T_PIPE_VAR) {
    //   return new PHP_Token_Pipe_Var();
    // }
    // const int UserTokenId_T_DICT = 442;
    // if ($tokenId == T_DICT) {
    //   return new PHP_Token_Dict();
    // }
    // const int UserTokenId_T_VEC = 443;
    // if ($tokenId == T_VEC) {
    //   return new PHP_Token_Vec();
    // }
    // const int UserTokenId_T_KEYSET = 444;
    // if ($tokenId == T_KEYSET) {
    //   return new PHP_Token_Keyset();
    // }
    // const int UserTokenId_T_WHERE = 445;
    // if ($tokenId == T_WHERE) {
    //   return new PHP_Token_Where();
    // }
    // const int UserTokenId_T_VARRAY = 446;
    // if ($tokenId == T_VARRAY) {
    //   return new PHP_Token_Varray();
    // }
    // const int UserTokenId_T_DARRAY = 447;
    // if ($tokenId == T_DARRAY) {
    //   return new PHP_Token_Darray();
    // }
    // const int UserTokenId_T_USING = 448;
    // if ($tokenId == T_USING) {
    //   return new PHP_Token_Using();
    // }
    // const int UserTokenId_T_INOUT = 449;
    // if ($tokenId == T_INOUT) {
    //   return new PHP_Token_Inout();
    // }
    // const int UserTokenId_T_TUPLE = 450;
    // if ($tokenId == T_TUPLE) {
    //   return new PHP_Token_Tuple();
    // }
    return null;

  }

  public static function createTokenFromName(string $name): ?TokenInterface {

    $templateToken = self::$_tokenTemplateCacheByName->get($name);

    if ($templateToken instanceof TokenInterface) {
      $token = clone $templateToken;
      return $token;
    }

    $templateToken = self::createTokenFromNameStepped($name);

    if ($templateToken instanceof TokenInterface) {
      self::$_tokenTemplateCacheByName->set($name, $templateToken);
      // We clone to make sure that we don't hand back a ref to our template.
      $token = clone $templateToken;
      return $token;
    }

    return null;

  }

  private static function createTokenFromNameStepped(
    string $name,
  ): ?TokenInterface {
    $token = null;

    $firstChar = substr($name, 10, 1);

    if ($firstChar == 'A') {
      $token = self::createToken_A($name);
    } else if ($firstChar == 'B') {
      $token = self::createToken_B($name);
    } else if ($firstChar == 'C') {
      $token = self::createToken_C($name);
    } else if ($firstChar == 'D') {
      $token = self::createToken_D($name);
    } else if ($firstChar == 'E') {
      $token = self::createToken_E($name);
    } else if ($firstChar == 'F') {
      $token = self::createToken_F($name);
    } else if ($firstChar == 'G') {
      $token = self::createToken_G($name);
    } else if ($firstChar == 'H') {
      $token = self::createToken_H($name);
    } else if ($firstChar == 'I') {
      $token = self::createToken_I($name);
    } else if ($firstChar == 'J') {
      $token = self::createToken_J($name);
    } else if ($firstChar == 'K') {
      $token = self::createToken_K($name);
    } else if ($firstChar == 'L') {
      $token = self::createToken_L($name);
    } else if ($firstChar == 'M') {
      $token = self::createToken_M($name);
    } else if ($firstChar == 'N') {
      $token = self::createToken_N($name);
    } else if ($firstChar == 'O') {
      $token = self::createToken_O($name);
    } else if ($firstChar == 'P') {
      $token = self::createToken_P($name);
    } else if ($firstChar == 'Q') {
      $token = self::createToken_Q($name);
    } else if ($firstChar == 'R') {
      $token = self::createToken_R($name);
    } else if ($firstChar == 'S') {
      $token = self::createToken_S($name);
    } else if ($firstChar == 'T') {
      $token = self::createToken_T($name);
    } else if ($firstChar == 'U') {
      $token = self::createToken_U($name);
    } else if ($firstChar == 'V') {
      $token = self::createToken_V($name);
    } else if ($firstChar == 'W') {
      $token = self::createToken_W($name);
    } else if ($firstChar == 'X') {
      $token = self::createToken_X($name);
    } else if ($firstChar == 'Y') {
      $token = self::createToken_Y($name);
    } else if ($firstChar == 'Z') {
      $token = self::createToken_Z($name);
    }
    return $token;
  }

  private static function createToken_A(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Abstract':
        return new PHP_Token_Abstract();
      case 'PHP_Token_Ampersand':
        return new PHP_Token_Ampersand();
      case 'PHP_Token_And_Equal':
        return new PHP_Token_And_Equal();
      case 'PHP_Token_Array':
        return new PHP_Token_Array();
      case 'PHP_Token_Array_Cast':
        return new PHP_Token_Array_Cast();
      case 'PHP_Token_As':
        return new PHP_Token_As();
      case 'PHP_Token_Async':
        return new PHP_Token_Async();
      case 'PHP_Token_At':
        return new PHP_Token_At();
      case 'PHP_Token_Await':
        return new PHP_Token_Await();
    }
    return null;
  }

  private static function createToken_B(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Backtick':
        return new PHP_Token_Backtick();
      case 'PHP_Token_Bad_Character':
        return new PHP_Token_Bad_Character();
      case 'PHP_Token_Bool_Cast':
        return new PHP_Token_Bool_Cast();
      case 'PHP_Token_Boolean_And':
        return new PHP_Token_Boolean_And();
      case 'PHP_Token_Boolean_Or':
        return new PHP_Token_Boolean_Or();
      case 'PHP_Token_Break':
        return new PHP_Token_Break();
    }
    return null;
  }

  private static function createToken_C(string $name): ?TokenInterface {

    switch ($name) {
      case 'PHP_Token_Callable':
        return new PHP_Token_Callable();
      case 'PHP_Token_Caret':
        return new PHP_Token_Caret();
      case 'PHP_Token_Case':
        return new PHP_Token_Case();
      case 'PHP_Token_Catch':
        return new PHP_Token_Catch();
      case 'PHP_Token_Character':
        return new PHP_Token_Character();
      case 'PHP_Token_Class':
        return new PHP_Token_Class();
      case 'PHP_Token_Class_C':
        return new PHP_Token_Class_C();
      case 'PHP_Token_Class_Name_Constant':
        return new PHP_Token_Class_Name_Constant();
      case 'PHP_Token_Clone':
        return new PHP_Token_Clone();
      case 'PHP_Token_Close_Bracket':
        return new PHP_Token_Close_Bracket();
      case 'PHP_Token_Close_Curly':
        return new PHP_Token_Close_Curly();
      case 'PHP_Token_Close_Square':
        return new PHP_Token_Close_Square();
      case 'PHP_Token_Close_Tag':
        return new PHP_Token_Close_Tag();
      case 'PHP_Token_Coalesce':
        return new PHP_Token_Coalesce();
      case 'PHP_Token_Colon':
        return new PHP_Token_Colon();
      case 'PHP_Token_Comma':
        return new PHP_Token_Comma();
      case 'PHP_Token_Comment':
        return new PHP_Token_Comment();
      case 'PHP_Token_Compiler_Halt_Offset':
        return new PHP_Token_Compiler_Halt_Offset();
      case 'PHP_Token_Concat_Equal':
        return new PHP_Token_Concat_Equal();
      case 'PHP_Token_Const':
        return new PHP_Token_Const();
      case 'PHP_Token_Constant_Encapsed_String':
        return new PHP_Token_Constant_Encapsed_String();
      case 'PHP_Token_Continue':
        return new PHP_Token_Continue();
      case 'PHP_Token_Curly_Open':
        return new PHP_Token_Curly_Open();
    }
    return null;
  }

  private static function createToken_D(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Dec':
        return new PHP_Token_Dec();
      case 'PHP_Token_Declare':
        return new PHP_Token_Declare();
      case 'PHP_Token_Default':
        return new PHP_Token_Default();
      case 'PHP_Token_Dir':
        return new PHP_Token_Dir();
      case 'PHP_Token_Div':
        return new PHP_Token_Div();
      case 'PHP_Token_Div_Equal':
        return new PHP_Token_Div_Equal();
      case 'PHP_Token_Dnumber':
        return new PHP_Token_Dnumber();
      case 'PHP_Token_Do':
        return new PHP_Token_Do();
      case 'PHP_Token_Doc_Comment':
        return new PHP_Token_Doc_Comment();
      case 'PHP_Token_Dollar':
        return new PHP_Token_Dollar();
      case 'PHP_Token_Dollar_Open_Curly_Braces':
        return new PHP_Token_Dollar_Open_Curly_Braces();
      case 'PHP_Token_Dot':
        return new PHP_Token_Dot();
      case 'PHP_Token_Double_Arrow':
        return new PHP_Token_Double_Arrow();
      case 'PHP_Token_Double_Cast':
        return new PHP_Token_Double_Cast();
      case 'PHP_Token_Double_Colon':
        return new PHP_Token_Double_Colon();
      case 'PHP_Token_Double_Quotes':
        return new PHP_Token_Double_Quotes();
    }
    return null;
  }

  private static function createToken_E(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Echo':
        return new PHP_Token_Echo();
      case 'PHP_Token_Ellipsis':
        return new PHP_Token_Ellipsis();
      case 'PHP_Token_Else':
        return new PHP_Token_Else();
      case 'PHP_Token_Elseif':
        return new PHP_Token_Elseif();
      case 'PHP_Token_Empty':
        return new PHP_Token_Empty();
      case 'PHP_Token_Encapsed_And_Whitespace':
        return new PHP_Token_Encapsed_And_Whitespace();
      case 'PHP_Token_Enddeclare':
        return new PHP_Token_Enddeclare();
      case 'PHP_Token_Endfor':
        return new PHP_Token_Endfor();
      case 'PHP_Token_Endforeach':
        return new PHP_Token_Endforeach();
      case 'PHP_Token_Endif':
        return new PHP_Token_Endif();
      case 'PHP_Token_Endswitch':
        return new PHP_Token_Endswitch();
      case 'PHP_Token_Endwhile':
        return new PHP_Token_Endwhile();
      case 'PHP_Token_End_HereDoc':
        return new PHP_Token_End_Heredoc();
      case 'PHP_Token_Enum':
        return new PHP_Token_Enum();
      case 'PHP_Token_Equal':
        return new PHP_Token_Equal();
      case 'PHP_Token_Equals':
        return new PHP_Token_Equals();
      case 'PHP_Token_Eval':
        return new PHP_Token_Eval();
      case 'PHP_Token_Exclamation_Mark':
        return new PHP_Token_Exclamation_Mark();
      case 'PHP_Token_Exit':
        return new PHP_Token_Exit();
      case 'PHP_Token_Extends':
        return new PHP_Token_Extends();
    }
    return null;
  }

  private static function createToken_F(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_File':
        return new PHP_Token_File();
      case 'PHP_Token_Final':
        return new PHP_Token_Final();
      case 'PHP_Token_Finally':
        return new PHP_Token_Finally();
      case 'PHP_Token_For':
        return new PHP_Token_For();
      case 'PHP_Token_Foreach':
        return new PHP_Token_Foreach();
      case 'PHP_Token_Func_C':
        return new PHP_Token_Func_C();
      case 'PHP_Token_Function':
        return new PHP_Token_Function();
    }
    return null;
  }

  private static function createToken_G(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Global':
        return new PHP_Token_Global();
      case 'PHP_Token_Goto':
        return new PHP_Token_Goto();
      case 'PHP_Token_Gt':
        return new PHP_Token_Gt();
    }
    return null;
  }

  private static function createToken_H(string $name): ?TokenInterface {
    if ($name == 'PHP_Token_Halt_Compiler') {
      return new PHP_Token_Halt_Compiler();
    }
    return null;
  }

  private static function createToken_I(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_If':
        return new PHP_Token_If();
      case 'PHP_Token_Implements':
        return new PHP_Token_Implements();
      case 'PHP_Token_In':
        return new PHP_Token_In();
      case 'PHP_Token_Inc':
        return new PHP_Token_Inc();
      case 'PHP_Token_Include':
        return new PHP_Token_Include();
      case 'PHP_Token_Include_Once':
        return new PHP_Token_Include_Once();
      case 'PHP_Token_Inline_Html':
        return new PHP_Token_Inline_Html();
      case 'PHP_Token_Instanceof':
        return new PHP_Token_Instanceof();
      case 'PHP_Token_Insteadof':
        return new PHP_Token_Insteadof();
      case 'PHP_Token_Int_Cast':
        return new PHP_Token_Int_Cast();
      case 'PHP_Token_Interface':
        return new PHP_Token_Interface();
      case 'PHP_Token_Invariant':
        return new PHP_Token_Invariant();
      case 'PHP_Token_Is_Equal':
        return new PHP_Token_Is_Equal();
      case 'PHP_Token_Is_Greater_Or_Equal':
        return new PHP_Token_Is_Greater_Or_Equal();
      case 'PHP_Token_Is_Identical':
        return new PHP_Token_Is_Identical();
      case 'PHP_Token_Is_Not_Equal':
        return new PHP_Token_Is_Not_Equal();
      case 'PHP_Token_Is_Not_Identical':
        return new PHP_Token_Is_Not_Identical();
      case 'PHP_Token_Is_Smaller_Or_Equal':
        return new PHP_Token_Is_Smaller_Or_Equal();
      case 'PHP_Token_Isset':
        return new PHP_Token_Isset();
    }
    return null;
  }

  private static function createToken_J(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Join':
        return new PHP_Token_Join();
    }
    return null;
  }

  private static function createToken_K(string $name): ?TokenInterface {
    return null; // No K tokens atm.
  }

  private static function createToken_L(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Lambda_Arrow':
        return new PHP_Token_Lambda_Arrow();
      case 'PHP_Token_Lambda_Cp':
        return new PHP_Token_Lambda_Cp();
      case 'PHP_Token_Lambda_Op':
        return new PHP_Token_Lambda_Op();
      case 'PHP_Token_Line':
        return new PHP_Token_Line();
      case 'PHP_Token_List':
        return new PHP_Token_List();
      case 'PHP_Token_Lnumber':
        return new PHP_Token_Lnumber();
      case 'PHP_Token_Logical_Or':
        return new PHP_Token_Logical_Or();
      case 'PHP_Token_Logical_Xor':
        return new PHP_Token_Logical_Xor();
      case 'PHP_Token_Logicial_And':
        return new PHP_Token_Logical_And();
      case 'PHP_Token_Lt':
        return new PHP_Token_Lt();
    }
    return null;
  }

  private static function createToken_M(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Method_C':
        return new PHP_Token_Method_C();
      case 'PHP_Token_Minus':
        return new PHP_Token_Minus();
      case 'PHP_Token_Minus_Equal':
        return new PHP_Token_Minus_Equal();
      case 'PHP_Token_Mod_Equal':
        return new PHP_Token_Mod_Equal();
      case 'PHP_Token_Mul_Equal':
        return new PHP_Token_Mul_Equal();
      case 'PHP_Token_Mult':
        return new PHP_Token_Mult();
    }
    return null;
  }

  private static function createToken_N(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Namespace':
        return new PHP_Token_Namespace();
      case 'PHP_Token_New':
        return new PHP_Token_New();
      case 'PHP_Token_Ns_C':
        return new PHP_Token_Ns_C();
      case 'PHP_Token_Ns_Separator':
        return new PHP_Token_Ns_Separator();
      case 'PHP_Token_Nullsafe_Object_Operator':
        return new PHP_Token_Nullsafe_Object_Operator();
      case 'PHP_Token_Num_String':
        return new PHP_Token_Num_String();
    }
    return null;
  }

  private static function createToken_O(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Object_Cast':
        return new PHP_Token_Object_Cast();
      case 'PHP_Token_Object_Operator':
        return new PHP_Token_Object_Operator();
      case 'PHP_Token_Onumber':
        return new PHP_Token_Onumber();
      case 'PHP_Token_Open_Bracket':
        return new PHP_Token_Open_Bracket();
      case 'PHP_Token_Open_Curly':
        return new PHP_Token_Open_Curly();
      case 'PHP_Token_Open_Square':
        return new PHP_Token_Open_Square();
      case 'PHP_Token_Open_Tag':
        return new PHP_Token_Open_Tag();
      case 'PHP_Token_Open_Tag_With_Echo':
        return new PHP_Token_Open_Tag_With_Echo();
      case 'PHP_Token_Or_Equal':
        return new PHP_Token_Or_Equal();
    }
    return null;
  }

  private static function createToken_P(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Paamayim_Nekudotayim':
        return new PHP_Token_Paamayim_Nekudotayim();
      case 'PHP_Token_Percent':
        return new PHP_Token_Percent();
      case 'PHP_Token_Pipe':
        return new PHP_Token_Pipe();
      case 'PHP_Token_Plus':
        return new PHP_Token_Plus();
      case 'PHP_Token_Plus_Equal':
        return new PHP_Token_Plus_Equal();
      case 'PHP_Token_Pow':
        return new PHP_Token_Pow();
      case 'PHP_Token_Pow_Equal':
        return new PHP_Token_Pow_Equal();
      case 'PHP_Token_Print':
        return new PHP_Token_Print();
      case 'PHP_Token_Private':
        return new PHP_Token_Private();
      case 'PHP_Token_Protected':
        return new PHP_Token_Protected();
      case 'PHP_Token_Public':
        return new PHP_Token_Public();
    }
    return null;
  }

  private static function createToken_Q(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Question_Mark':
        return new PHP_Token_Question_Mark();
    }
    return null;
  }

  private static function createToken_R(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Require':
        return new PHP_Token_Require();
      case 'PHP_Token_Require_Once':
        return new PHP_Token_Require_Once();
      case 'PHP_Token_Return':
        return new PHP_Token_Return();
    }
    return null;
  }

  private static function createToken_S(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Semicolon':
        return new PHP_Token_Semicolon();
      case 'PHP_Token_Shape':
        return new PHP_Token_Shape();
      case 'PHP_Token_Sl':
        return new PHP_Token_Sl();
      case 'PHP_Token_Sl_Equal':
        return new PHP_Token_Sl_Equal();
      case 'PHP_Token_Spaceship':
        return new PHP_Token_Spaceship();
      case 'PHP_Token_Sr':
        return new PHP_Token_Sr();
      case 'PHP_Token_Sr_Equal':
        return new PHP_Token_Sr_Equal();
      case 'PHP_Token_Start_Heredoc':
        return new PHP_Token_Start_Heredoc();
      case 'PHP_Token_Static':
        return new PHP_Token_Static();
      case 'PHP_Token_String':
        return new PHP_Token_String();
      case 'PHP_Token_String_Cast':
        return new PHP_Token_String_Cast();
      case 'PHP_Token_String_Varname':
        return new PHP_Token_String_Varname();
      case 'PHP_Token_Super':
        return new PHP_Token_Super();
      case 'PHP_Token_Switch':
        return new PHP_Token_Switch();
    }
    return null;
  }

  private static function createToken_T(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Throw':
        return new PHP_Token_Throw();
      case 'PHP_Token_Tilde':
        return new PHP_Token_Tilde();
      case 'PHP_Token_Trait':
        return new PHP_Token_Trait();
      case 'PHP_Token_Trait_C':
        return new PHP_Token_Trait_C();
      case 'PHP_Token_Try':
        return new PHP_Token_Try();
      case 'PHP_Token_Tuple':
        return new PHP_Token_Tuple();
      case 'PHP_Token_Type':
        return new PHP_Token_Type();
      case 'PHP_Token_Typelist_Gt':
        return new PHP_Token_Typelist_Gt();
      case 'PHP_Token_Typelist_Lt':
        return new PHP_Token_Typelist_Lt();
    }
    return null;
  }

  private static function createToken_U(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Unset':
        return new PHP_Token_Unset();
      case 'PHP_Token_Unset_Cast':
        return new PHP_Token_Unset_Cast();
      case 'PHP_Token_Use':
        return new PHP_Token_Use();
      case 'PHP_Token_Use_Function':
        return new PHP_Token_Use_Function();
    }
    return null;
  }

  private static function createToken_V(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Var':
        return new PHP_Token_Var();
      case 'PHP_Token_Variable':
        return new PHP_Token_Variable();
    }
    return null;
  }

  private static function new_PHP_Token_Whitespace(
    string $name,
  ): TokenInterface {
    return new PHP_Token_Whitespace();
  }

  private static function createToken_W(string $name): ?TokenInterface {

    if ($name == 'PHP_Token_Whitespace') {
      return new PHP_Token_Whitespace();
    }

    if ($name == 'PHP_Token_Where') {
      return new PHP_Token_Where();
    }

    if ($name == 'PHP_Token_While') {
      return new PHP_Token_While();
    }

    return null;
  }

  private static function createToken_X(string $name): ?TokenInterface {
    switch ($name) {
      case 'PHP_Token_Xhp_Attribute':
        return new PHP_Token_Xhp_Attribute();
      case 'PHP_Token_Xhp_Category':
        return new PHP_Token_Xhp_Category();
      case 'PHP_Token_Xhp_Category_Label':
        return new PHP_Token_Xhp_Category_Label();
      case 'PHP_Token_Xhp_Children':
        return new PHP_Token_Xhp_Children();
      case 'PHP_Token_Xhp_Label':
        return new PHP_Token_Xhp_Label();
      case 'PHP_Token_Xhp_Required':
        return new PHP_Token_Xhp_Required();
      case 'PHP_Token_Xhp_Tag_Gt':
        return new PHP_Token_Xhp_Tag_Gt();
      case 'PHP_Token_Xhp_Tag_Lt':
        return new PHP_Token_Xhp_Tag_Lt();
      case 'PHP_Token_Xhp_Text':
        return new PHP_Token_Xhp_Text();
      case 'PHP_Token_Xor_Equal':
        return new PHP_Token_Xor_Equal();
    }
    return null;
  }

  private static function createToken_Y(string $name): ?TokenInterface {
    if ($name == 'PHP_Token_Yield') {
      return new PHP_Token_Yield();
    }
    return null;
  }

  private static function createToken_Z(string $name): ?TokenInterface {
    return null; // no Z based tokens atm.
  }

}
